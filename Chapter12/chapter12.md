# Tuning for Speed
* Code should run as fast as necessary, but no faster. - Richard E. pattis -
* 파트 1과 파트 2에서 Core Animation이 제공해야하는 멋진 그림과 애니메이션 기능에 대해 배웠다. Core Animation은 강력하고 빠르지만 뒤에서 무슨 일이 벌어지고 있는지 명확하지 않은 경우 비효율적으로 사용하기 쉽다. 최고의 성능을 발휘하는 기술이 있다. 이 장에서는 애니메이션이 느리게 실행되는 이유와 문제를 진단하고 해결할 수 있는 몇가지 방법에 대해 살펴볼 것이다.

## CPU Versus GPU
* Drawing과 Animation에는 CPU(중앙 처리 장치)와 GPU(그래픽 처리 장치)라는 두가지 유형이 있다. 현대의 iOS 디바이스에서 이것은 임의의 소프트웨어를 실행할 수 있는 프로그램가능한 칩이지만, 역사적인 이유로 CPU에서 수행되는 작업의 일부는 "소프트웨어"로 수행되는 경항이 있으며, GPU에 의해 처리되는 부분은 "하드웨어"에서 실행된다.
* 일반적으로 말하면, 우리는 소프트웨어(CPU 사용)에서 어떠한 것이든 할 수 있지만, 그래픽 처리를 위해서는 일반적으로 GPU가 그래픽스에서 사용되는 병렬 부동 소수점 연산의 정렬에 최적화되어 있기 때문에 하드웨어를 사용하는것이 훨씬 빠르다. 이러한 이유로 가능한 많은 화면 렌더링을 하드웨어에 제공하는 것이 이상적이다. 문제는 GPU에 무제한 처리 능력이 없으며, 이미 전체 용량 사용되면 선응이 저하되기 시작한다는 것이다.(CPU가 완전히 사용되지 않더라도)
* 대부분의 애니메이션 성능 최적화는 GPU와 CPU를 지능석으로 활용하여 어느쪽도 과부화되지 않도록하는 것이다. 그러기 위해서는 Core Animation이 이러한 프로세서간에 작업을 어떻게 분할하는지 먼저 이해해야한다.

### The Stages of an Animation
* Core Animation은 iOS의 핵심이다. 단일 애니메이션은 iPad에서 제스처를 사용하여 앱을 전환할 때 두 화면을 하나의 화면에 잠깐 표시하는 등 여러 앱의 콘텐츠를 동시에 표시할 수 있다. iOS가 이러한 종류의 효과를 구현할 수 없기 때문에 특정 앱의 코드 내부에서 이 애니메이션을 수행하는 것은 의미가 없다.(앱은 샌드박스 처리되어 서로의 의견에 액세스 할 수 없다.)
* 화면에 레이어 애니메이션 및 합성은 실제로 응용 프로그램 외부의 별도 프로세스에 의해 처리된다. 이 프로세스를 렌더 서버라고한다. iOS5 이전에는 SpringBoard 프로세스(이것은 iOS 홈 화면에서도 동작함)이고, iOS 6 이후엔 BackBoard라는 새로운 프로세스에 의해 처리된다.
* 애니메이션을 수행작업은 다음과 같은 4개의 개별 단계로 나뉜다.
  * Layout - 뷰 / 레이어 계층을 준비하고 레이어 속성(프레임, 배경색, 테두리 등)을 설정하는 단계
  * Display - 레이어의 뒷면 이미지가 그려지는 곳이다. 이 그림에는 drawRect 또는 drawLayer: inContext: 메소드에 작성한 루틴이 포함될수 있다.
  * Prepare - Core Animation이 애니메이션 데이터를 렌더 서버로 보낼 준비가 되는 단계이다. 이것은 Core Animation이 애니메이션 도중 표시 될 이미지 압축 해제와 같은 다른 임무를 수행하는 지점이기도 한다.(자세한 내용은 나중에 설명)
  * Commit-Core - 애니메이션이 레이어와 애니메이션 속성을 패키지화 하고 IPC(Inter-Process Communication)를 통해 렌더링 서버로 보내어 표시하는 최종단계이다.

* 그러나 이것들은 어플리케이션 내부에서 일어나는 단계일 뿐이다. 애니메이션이 화면에 나타나기전에 해야할 일이 아직 많이 남아있다. 패키징 된 레이어와 애니메이션이 렌더 서버 프로세스에 도착했을 때 렌더 트리라고하는 다른 레이어 트리를 만들기 위해 직렬화가 해제된다.(1장 "레이어 트리" 참조) 이 트리를 사용하여 렌더링 서버는 애니메이션의 각 프레임에 대해 다음을 수행한다.
  * 모든 레이어 속성의 중간 값을 계산하고 OpenGL 지오메트리(textured triangles)를 설정하여 렌더링을 수행한다.
  * 화면에 보이는 삼각형을 렌더링한다.

* 이것까지 총 6단계 이다. 마지막 두개는 애니메이션 기간 동안 계속해서 반복된다.이 단계의 처음 다섯 단계는 소프트웨어(CPU)에 의해 처리되며, 마지막 단계는 GPU에서 처리된다. 또한 처음 두 단계(Layout and Display)를 직접 제어할 수 있다. Core Animation 프레임워크는 내부적으로 나머지를 처리하므로 사용자는 이를 제어할 수 없다.
* Layout과 Display 단계에서 어떤 작업이 CPU에서 수행되고 GPU에 무엇이 전달 될지 결정해야 하기 때문에 실제로는 문제가 아니다. 그렇다면 어떻게 이러한 결정을 내릴 수 있을까?